{"name":"Path-class","tagline":"Cross-platform path spec manipulation for Perl","body":"# SYNOPSIS\r\n\r\n```\r\n  use Path::Class;\r\n  \r\n  my $dir  = dir('foo', 'bar');       # Path::Class::Dir object\r\n  my $file = file('bob', 'file.txt'); # Path::Class::File object\r\n  \r\n  # Stringifies to 'foo/bar' on Unix, 'foo\\bar' on Windows, etc.\r\n  print \"dir: $dir\\n\";\r\n  \r\n  # Stringifies to 'bob/file.txt' on Unix, 'bob\\file.txt' on Windows\r\n  print \"file: $file\\n\";\r\n  \r\n  my $subdir  = $dir->subdir('baz');  # foo/bar/baz\r\n  my $parent  = $subdir->parent;      # foo/bar\r\n  my $parent2 = $parent->parent;      # foo\r\n  \r\n  my $dir2 = $file->dir;              # bob\r\n\r\n  # Work with foreign paths\r\n  use Path::Class qw(foreign_file foreign_dir);\r\n  my $file = foreign_file('Mac', ':foo:file.txt');\r\n  print $file->dir;                   # :foo:\r\n  print $file->as_foreign('Win32');   # foo\\file.txt\r\n  \r\n  # Interact with the underlying filesystem:\r\n  \r\n  # $dir_handle is an IO::Dir object\r\n  my $dir_handle = $dir->open or die \"Can't read $dir: $!\";\r\n  \r\n  # $file_handle is an IO::File object\r\n  my $file_handle = $file->open($mode) or die \"Can't read $file: $!\";\r\n```\r\n\r\n# DESCRIPTION\r\n\r\n`Path::Class` is a module for manipulation of file and directory\r\nspecifications (strings describing their locations, like\r\n`'/home/ken/foo.txt'` or `'C:\\Windows\\Foo.txt'`) in a cross-platform\r\nmanner.  It supports pretty much every platform Perl runs on,\r\nincluding Unix, Windows, Mac, VMS, Epoc, Cygwin, OS/2, and NetWare.\r\n\r\nThe well-known module <File::Spec> also provides this service, but\r\nit's sort of awkward to use well, so people sometimes avoid it, or use\r\nit in a way that won't actually work properly on platforms\r\nsignificantly different than the ones they've tested their code on.\r\n\r\nIn fact, `Path::Class` uses `File::Spec` internally, wrapping all\r\nthe unsightly details so you can concentrate on your application code.\r\nWhereas `File::Spec` provides functions for some common path\r\nmanipulations, `Path::Class` provides an object-oriented model of the\r\nworld of path specifications and their underlying semantics.\r\n`File::Spec` doesn't create any objects, and its classes represent\r\nthe different ways in which paths must be manipulated on various\r\nplatforms (not a very intuitive concept).  `Path::Class` creates\r\nobjects representing files and directories, and provides methods that\r\nrelate them to each other.  For instance, the following `File::Spec`\r\ncode:\r\n\r\n```\r\n my $absolute = File::Spec->file_name_is_absolute(\r\n                  File::Spec->catfile( @dirs, $file )\r\n                );\r\n```\r\ncan be written using `Path::Class` as\r\n\r\n```\r\n my $absolute = Path::Class::File->new( @dirs, $file )->is_absolute;\r\n```\r\n\r\nor even as \r\n\r\n```\r\n my $absolute = file( @dirs, $file )->is_absolute;\r\n```\r\n\r\nSimilar readability improvements should happen all over the place when\r\nusing `Path::Class`.\r\n\r\nUsing `Path::Class` can help solve real problems in your code too -\r\nfor instance, how many people actually take the \"volume\" (like `C:`\r\non Windows) into account when writing `File::Spec`-using code?  I\r\nthought not.  But if you use `Path::Class`, your file and directory objects\r\nwill know what volumes they refer to and do the right thing.\r\n\r\nThe guts of the `Path::Class` code live in the `Path::Class::File`\r\nand `Path::Class::Dir` modules, so please see those\r\nmodules' documentation for more details about how to use them.\r\n\r\n# AUTHOR\r\n\r\nKen Williams, KWILLIAMS@cpan.org\r\n\r\n# COPYRIGHT\r\n\r\nCopyright (c) Ken Williams.  All rights reserved.\r\n\r\nThis library is free software; you can redistribute it and/or\r\nmodify it under the same terms as Perl itself.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}